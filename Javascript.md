### JavaScript/ES6

#### **一、JS数组常用方法**

| 方法                      | 说明                                                         |
| ------------------------- | ------------------------------------------------------------ |
| push()                    | 添加元素到数组末尾                                           |
| pop()                     | 删除数组末尾元素                                             |
| unshift()                 | 添加元素到数组的头部                                         |
| shift()                   | 删除数组最前面元素                                           |
| indexOf()                 | 查看某个元素在数组中的位置                                   |
| splice(start, num, value) | 实现增删改操作（start开始下标，num删除元素个数，value插入或替换的元素） |
| slice(begin, end)         | 浅拷贝数组并返回拷贝后的新数组                               |
| Array.from()              | 从一个类似数组或可迭代对象中创建一个新的数组实例             |
| fill(value, start, end)   | 用一个固定值填充数组中[start,end)的全部元素                  |
| forEach                   |                                                              |

#### **二、mouseover和mouseenter的区别**

mouseover/mouseout：当鼠标移入元素或其子元素都会触发事件，有一个重复触发的冒泡过程

mouseenter/mouseleave：当鼠标移入元素本身（不包含元素的子元素）会触发事件，即不会冒泡

#### **三、clientHeight, scrollHeight, offsetHeight ,以及scrollTop, offsetTop, clientTop的区别？**

clientHeight：可视区域高度，不包含border和滚动条
offsetHeight： 可视区域高度，包含border和滚动条
scrollHeight：所有区域高度，包含因滚动被隐藏的部分
clientTop：边框border的厚度
scrollTop：滚动后被隐藏的高度，获取对象最顶端与窗口中可见内容最顶端之间的距离
offsetTop：获取指定对象相对于版面或布局中设置position属性的父容器顶端位置的距离

<img src="./images/浏览器宽高.jpg" />

#### **四、JS类型判断**

typeof A、A instanceof B、Object.prototype.toString.call (A)

注意：数组判断不能用typeof（typeof只能判断是否是object）



#### **五、如何获得对象上的属性**

- for(let l in obj)：遍历一个对象及其原型链中所有可枚举的属性
- object.keys：返回一个包含所有可枚举的属性名称的数组
- object.getOwnPropertyNames：返回一个包含不可枚举的属性的数组（基本包装类型的原型属性不可枚举，如Object、Array、Number等）

#### **六、JS语言特点**

- 运行在客户端浏览器上
- 不用预编译，直接解析执行代码
- 弱类型语言，较为灵活
- 与操作系统无关，跨平台
- 脚本语言、解释性语言

#### **七、JS中string的startswith和indexof两种方法的区别**

- str.startsWith(searchString, position)
  searchString：要搜素的子字符串
  position（可选）：搜索searchString的开始位置，默认为0
  能找到返回true，找不到返回false
- str.indexOf(searchValue, fromIndex)
  searchValue：要搜索的字符串
  fromIndex（可选）：开始查找的位置，默认为0
  没找到返回-1，否则返回searchValue第一次出现的索引

#### **八、ES6有哪些新特性？**

- 新增let、const声明变量，实现了块级作用域

- 新增箭头函数

- 引入promise、await/async解决异步回调问题

- 引入Class作为对象的模板，实现更好的面向对象编程

- 引入模块方便模块化编程

- 引入新的数据类型symbol，新的数据结构set和map

  

#### **九、let、const、var区别**

| 类型  | 变量提升 | 暂时性死区 | 重复声明 | 初始值 | 作用域                 |
| ----- | -------- | ---------- | -------- | ------ | ---------------------- |
| var   | 存在     | 不存在     | 允许     | 不需要 | 全局作用域、函数作用域 |
| let   | 不存在   | 存在       | 不允许   | 不需要 | 块级作用域             |
| const | 不存在   | 存在       | 不允许   | 需要   | 块级作用域             |

变量提升：变量可在声明前使用
暂时性死区：代码块内，使用let、const声明变量之前，该变量都是不可用的

#### **十、==和===、以及Object.is的区别**

==：两边值类型不同时，强制转换成number再进行比较（null==undefined→true）

===：严格比较运算符，不会进行强制类型转换（+0===-0 true；NaN===NaN false）

Object.is()：与===基本一致（Object.is(+0,-0) false；Object.is(NaN,NaN) true）

#### **十一、setTimeout、setInterval和requestAnimationFrame**

| 名称                      | 说明                                                         |
| ------------------------- | ------------------------------------------------------------ |
| setTimeout/clearTimeout   | 延时执行参数指定代码                                         |
| setInterval/clearInterval | 每隔一段时间执行指定代码                                     |
| requestAnimationFrame     | 在浏览器每次刷新页面之前执行：1. 会把每一帧中所有的DOM操作集中起来，在一次重绘或回流中就完成，并且重绘或回流的时间间隔紧紧跟随浏览器的刷新频率；2. 对于隐藏元素不会进行重绘或回流，减少了CPU、GPU和内存使用量；3. 由浏览器专门为动画提供的API，在运行时浏览器会自动优化方法的调用；页面如果不是激活状态，动画会暂停播放，有效节省了CPU开销 |

#### **十二、高频度触发事件的优化方案**

| 方案         | 说明                                       | 应用场景                   |
| ------------ | ------------------------------------------ | -------------------------- |
| 防抖debounce | 抖动结束的时间超过指定时间间隔时才执行任务 | 搜索联想、窗口resize       |
| 节流throttle | 指定时间间隔内只执行一次任务               | 滚动事件、鼠标不断点击触发 |

#### **十三、JS类有哪几种继承方式？各有什么特点？**

- 原型链继承：将父类实例作为子类原型
  特点：基于原型链，既是父类的实例，又是子类的实例
  缺点：无法实现多继承，无法向父类构造参数传参

- 构造继承：使用父类的构造函数来增强子类实例
  特点：可以实现多继承
  缺点：只能继承父类的实例属性和方法，不能继承原型上的属性和方法

- 实例继承：为父类实例添加新特性，作为子类实例返回
  特点：不限制调用方法
  缺点：实例是父类的实例，不是子类的实例，不支持多继承

- 拷贝继承：拷贝父类元素上的属性和方法
  特点：支持多继承
  缺点：效率低、内存占用高

- 组合继承：构造继承+原型链继承
  特点：可以继承实例属性和方法，也可以继承原型属性和方法
  缺点：调用两次父类构造函数，会生成两份实例

- 寄生组合继承：通过寄生方式，砍掉组合继承中父类的实例属性
  特点：避免组合继承中初始化两次实例方法和属性

  参考：[说一下类的创建和继承](https://github.com/jinzita007/studies/issues/2) [JS原型链与继承别再被问倒了](https://juejin.im/post/58f94c9bb123db411953691b#heading-8)



#### **十四、js的new操作符做了哪些事情**

1. 创建一个类的实例：创建一个空对象obj，将obj.*proto*设置为构造函数的prototype
2. 初始化实例：构造函数被传入参数并调用，this指针被设定为指向该实例obj
3. 返回实例obj

#### **十五、改变函数内部this指针可以使用哪些函数？有什么区别？**

- call()：第一个参数为要改变指向的对象，之后的参数为arg1，arg2…，函数立即执行
- apply()：第一个参数为要改变指向的对象，之后的参数为一个数组arguments，函数立即执行
- bind()：返回一个新的函数，函数不会立即执行

call和apply作用：改变this的指向；借用别的对象的方法；调用函数

#### **十六、如何解决js加载过程阻塞问题？**

1. 将script标签放到body底部：此时DOM已加载完毕因此不存在阻塞问题（并非异步策略）

2. 异步加载外部js文件：defer、async

   defer属性：给script标签设置defer属性，将脚本文件设置为延迟加载，遇到带有defer属性的script标签时，浏览器会再开启一个线程去下载js文件，同时继续解析HTML文档，等HTML全部解析完毕DOM加载完成后，再去执行加载好的js文件，可以保证多个js文件的执行顺序就是它们在页面中的出现顺序
   async属性：类似于defer属性，但与defer不同的是，它会在下载完毕后立刻执行。对于多个带有async的js文件，不保证按顺序执行，哪个js文件先下载完就先执行哪个

#### **十七、什么是闭包？闭包有什么用？**

闭包：能够访问其他函数作用域中的变量的函数

应用：模仿块级作用域；保存外部函数的变量；封装私有变量（单例模式）

闭包与堆内存：闭包中的变量并不保存在栈内存中，而是保存在堆内存中，所以函数调用之后闭包还能引用到函数内的变量

#### **十八、什么是立即执行函数（IIFE）？有何特点？有什么用处？**

(function(){
//执行语句
})();

特点：立即执行函数中的代码，又不会在内存中留下对该函数的引用；函数内部的所有变量都会被立即销毁（除非这些变量赋值给了包含作用域中的变量）
作用：实现块级作用域

#### **十九、如何理解前端模块化**

模块化思想：隔离不同的js文件，仅暴露当前模块所需要的其他模块

将复杂的文件编成一个个独立的模块，有利于复用和维护。但会产生模块之间相互依赖的问题，可通过js打包工具webpack解决

#### **二十、ES6模块化** 

1.ES6模块中自动采用严格模式，规定：

- 变量必须先声明
- 函数参数不能有同名属性
- 禁止this指向全局
- 对只读属性赋值、删除不可删除属性直接报错
- arguments不可重新赋值，不会自动反应函数参数变化
- 增加保留字static、interface、producted等

2.**export** export语句输出的接口是对应值的引用，也就是一种动态绑定关系，通过该接口可以获取模块内部实时的值；export命令要处于模块顶层 

- 把export直接加到声明前面
- export {a, b, c}
- export default默认导出（一个js文件中只能有一个默认导出，但可以导出多个方法）

3.**import** import是静态执行，Singleton模式；import命令要处于模块顶层

- import {XX} from ‘./test.js’
- import {XX as YY} from ‘./test.js’
- import * as YY from ‘./test.js’

#### **二十二、JS垃圾回收的两种方法**

- 标记清除：总体思想是将寻找不再使用的对象变为寻找无法到达的对象，即从根部（全局对象）出发定时扫描内存中的对象，凡是能从根部到达的对象都是还需要使用的。
  1. 垃圾收集器在运行的时候会给存储在内存中的所有变量都加上标记
  2. 从根部出发将能触及到的对象的标记清除
  3. 还存在标记的变量被视为准备删除的变量
  4. 垃圾收集器执行最后一步内存清除工作，销毁那些带标记的值并回收它们所占用的内存空间
- 引用计数：统计引用类型变量声明后被引用次数，当次数为0时该变量被回收。

#### **二十三、什么是内存泄露？常见的内存泄露有哪些？如何避免？**

1. 定义：由于疏忽或错误造成程序未能释放那些已经不再使用的内存，造成内存的浪费
2. 案例：
   - 由于未声明而意外产生的全局变量
   - 没有回收的定时器和回调函数
   - 闭包（闭包之间是共享作用域的）
   - DOM元素的引用
3. 解决方案：
   - 减少不必要的全局变量，使用严格模式避免意外创建全局变量
   - 使用完数据后及时解除引用（DOM引用、闭包中的变量、定时器清除）
   - 组织好函数逻辑，避免死循环等造成浏览器卡顿和崩溃

参考：[「前端进阶」JS中的内存管理](https://juejin.im/post/5d0706a6f265da1bc23f77a9)

#### **二十四、js内存空间**

- 栈：存放变量
- 堆：存放复杂对象
- 池（一般也归类为栈中）：存放常量

栈内存由于自身数据结构的特点，系统效率较高；堆内存需要分配空间和地址，还要把地址存到栈中，所以效率低于栈

#### **二十五、js基本数据类型有哪些？引用数据类型有哪些？基本数据类型和引用数据类型的区别？**

 基本数据类型：null、undefined、symbol、boolean、string、number

引用数据类型：Object、Array、RegExp、Date、Function、特殊的基本包装类型（String、Number、Boolean）、单体内置对象（Global、Math）

区别：

1. 基本数据类型的比较是值的比较；引用数据类型比较的是内存地址是否相同
2. 基本数据类型存放在栈区；引用数据类型同时存放在栈区和堆区
3. 基本数据类型的赋值是简单赋值；引用数据类型赋值是对象引用
4. 基本数据类型不能添加引用和方法；引用数据类型可以

#### **二十六、变量类型与内存的关系**

- 基本数据类型存放在栈区（栈内存中的变量一般在其当前执行环境结束就会被销毁和回收）

  基本数据类型占用空间小、大小固定，按值访问，属于被频繁使用的数据。

- 引用数据类型存放在栈区和堆区（堆内存中的变量只有在所有对它的引用都结束时才会被回收）

  引用数据类型占用空间大、大小不固定，若存储在栈中会影响程序运行的性能；但引用数据类型的指针存储在栈中，该指针指向堆中该实体的起始地址。当解释器寻找引用值时，会先检索其在栈中的地址，取得地址后再从堆中获得实体。

#### **二十七、跨域原理？js实现跨域**

 跨域：浏览器不能执行其他网站的脚本，是由浏览器的同源策略造成的，是浏览器对JS实施的安全限制
（只要协议、域名、端口有任何一个不同，都被当作是不同的域）

跨域原理：通过各种方式避开浏览器的安全限制

实现方法：CORS；代理服务器；JSONP；document.domain+iframe；location.hash+iframe；window.name+iframe；postMessage

#### **二十八、什么是symbol** 

ES6新增属性，Symbol(description)函数生成一个全局唯一的值，能够作为对象属性的标识符；description为字符串类型，仅作为对symbol的描述，相当于一个注释。

#### **二十九、this的指向有哪几种**

- 默认绑定：全局环境中this默认绑定到window
- 隐式绑定：被直接对象所包含的函数调用时，即方法调用时，this隐式绑定到该对象上
- 隐式丢失：被隐式绑定的函数丢失绑定对象时，会默认绑定到window
- 显示绑定：通过call()、apply()、bind()方法把对象绑定到this上
- new绑定：函数或方法调用前带有关键字new，就构成构造函数调用，对于this绑定来说，称为new绑定

#### **三十、ES6箭头函数与普通函数的区别**

1. 箭头函数没有this，需要通过查找作用域链来确定this的值，即如果箭头函数被非箭头函数包含，this绑定的就是最近一层非箭头函数的this
2. 箭头函数没有自己的arguments对象，但是可以访问外围函数的arguments对象
3. 不能通过new关键字调用，无原型

llllllll





